use crate::{error, HmacSha512, Result};
use hex;
use pbkdf2::pbkdf2;
use rand::Rng;
use sha2::Digest;
use std::fs::File;
use std::io::Read;
use unicode_normalization::UnicodeNormalization;

const MNEMONIC: &str = "mnemonic";

/*
Rust implementation for Bip39

Reference: https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
 */
pub struct Bip39 {
    pub wordlist: Vec<String>,
    /*
    We refer to the initial entropy length as ENT.
    The allowed size of ENT is 128-256 bits.
     */
    ent: usize,
}

impl Bip39 {
    pub fn new<S: Into<String>>(ent: usize, filepath: S) -> Result<Self> {
        let filepath = filepath.into();
        let mut file = File::open(filepath.clone()).map_err(|_| error::Error::OpenWordlist {
            filepath: filepath.clone()
        })?;
        let mut data = String::from("");
        file.read_to_string(&mut data)
            .map_err(|_| error::Error::ReadFile {
                filepath
            })?;
        let wordlist: Vec<String> =
            serde_json::from_str(data.as_str()).map_err(|_| error::Error::JsonSerialization)?;

        Ok(Self { wordlist, ent })
    }

    /*
    The mnemonic must encode entropy in a multiple of 32 bits.
    With more entropy security is improved but the sentence length increases.
     */
    pub fn generate_entropy(&self) -> String {
        let mut rng = rand::thread_rng();
        let entropy: Vec<String> = (0..self.ent / 4)
            .map(|_| format!("{:x}", rng.gen_range(0..15)))
            .collect();

        entropy.join("")
    }

    pub fn generate_mnemonic<S: Into<String>>(&self, entropy: S) -> String {
        let entropy = entropy.into();
        let c_sum = self.check_sum(&entropy);

        // Convert hex string into binary string
        let binaries = entropy
            .chars()
            .map(|e| format!("{:0>4}", format!("{:b}", e.to_digit(16).unwrap())))
            .collect::<String>();
        // This checksum is appended to the end of the initial entropy.
        let binaries = format!("{}{}", binaries, c_sum);

        let mut mnemonic = Vec::new();
        // MS = (ENT + CS) / 11
        let ms = self.ent + c_sum.len();
        let step: usize = 11;
        // these concatenated bits are split into groups of 11 bits
        for i in (0..ms).step_by(step) {
            let chars = binaries.chars();
            // similar with substring(i, step)
            let chunk: String = chars.into_iter().skip(i).take(step).collect();
            if let Ok(index) = usize::from_str_radix(chunk.as_str(), 2) {
                // each encoding a number from 0-2047, serving as an index into a wordlist
                if let Some(word) = self.wordlist.get(index) {
                    mnemonic.push(word.clone());
                }
            }
        }

        //  we convert these numbers into words and use the joined words as a mnemonic sentence.
        let mnemonic = mnemonic.join(" ");

        mnemonic
    }

    // A checksum is generated by taking the first ENT / 32 bits of its SHA256 hash.
    pub fn check_sum<S: Into<String>>(&self, entropy: S) -> String {
        let hex = format!("{:x}", sha2::Sha256::digest(&hex::decode(entropy.into()).unwrap()));
        return hex
            .chars()
            .into_iter()
            .map(|c| format!("{:0>4}", format!("{:b}", c.to_digit(16).unwrap())))
            .collect::<String>()[..self.ent / 32]
            .to_string();
    }

    /*
    A user may decide to protect their mnemonic with a passphrase.
    If a passphrase is not present, an empty string "" is used instead.
    */
    pub fn mnemonic_to_seed<S1, S2>(&self, mnemonic: S1, passphrase: S2) -> String
    where
        S1: Into<String>,
        S2: Into<String>,
    {
        let mnemonic = mnemonic.into();
        let passphrase = passphrase.into();
        // To create a binary seed from the mnemonic,
        // we use the PBKDF2 function with a mnemonic sentence used as the password
        let password = mnemonic.as_str().nfkd().collect::<String>();
        let slat = format!("{}{}", MNEMONIC, passphrase)
            .nfkd()
            .collect::<String>();

        // The length of the derived key is 512 bits (= 64 bytes).
        let mut hash_password = [0u8; 64];

        // The iteration count is set to 2048
        pbkdf2::<HmacSha512>(
            password.as_bytes(),
            slat.as_bytes(),
            2048,
            &mut hash_password,
        );

        hex::encode(hash_password)
    }
}

#[cfg(test)]
mod tests {
    use crate::bip39::Bip39;
    const WORDLIST_PATH: &str = "./src/resources/wordlists.json";

    #[test]
    fn generate_mnemonic() {
        let bip39 = Bip39::new(32 * 4, WORDLIST_PATH).unwrap();
        let entropy = bip39.generate_entropy();
        let _mnemonic = bip39.generate_mnemonic(entropy);
    }

    #[test]
    fn generate_128_bits_mnemonic() {
        let bip39 = Bip39::new(32 * 4, WORDLIST_PATH).unwrap();
        let entropy = "5ce32d93e6c655dd7c627b9a301372b7";
        let mnemonic = bip39.generate_mnemonic(entropy);
        assert_eq!(
            "friend bonus gossip snow grab upgrade various exhaust olive letter syrup hover",
            mnemonic
        );
    }

    #[test]
    fn generate_256_bits_mnemonic() {
        let bip39 = Bip39::new(32 * 8, WORDLIST_PATH).unwrap();
        let entropy = "8bb698160ec02122eed57e8dead157bcbe54d7297d017e97e7848b98b70b4be9";
        let mnemonic = bip39.generate_mnemonic(entropy);
        assert_eq!(
            "merry regular airport budget acoustic multiply robust quit mistake final field just torch high planet parent leader sand thrive blame merge mad cook damp",
            mnemonic
        );
    }

    #[test]
    fn mnemonic_to_seed() {
        let bip39 = Bip39::new(32 * 5, WORDLIST_PATH).unwrap();
        let entropy = "1d9a7146fd631640bc56a566c4511e5b3a2bcda3";
        let mnemonic = bip39.generate_mnemonic(entropy);
        assert_eq!(
            "budget squeeze faculty width cousin cake vanish start grocery card elegant reopen pencil traffic minute",
            mnemonic
        );
        let passphrase = "123";
        assert_eq!(
            "37b92480d76e320f3a3227ab897c3680f7ec84dfc949220e1dec50d2abf64e918623e6ae7d1792a1de2fa0825ef804ed676056dc530a7bc96d8f86941fad27b5",
            bip39.mnemonic_to_seed(mnemonic, passphrase)
        );
    }
}
